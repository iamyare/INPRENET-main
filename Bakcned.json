{
  "backend-nest": {
    "src": {
      "guards": {
        "auth": {
          "auth.guard.ts": "import { Injectable, CanActivate, ExecutionContext } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n    constructor(private reflector: Reflector) {}\n\n    canActivate(context: ExecutionContext): boolean {\n      const requiredRoles = this.reflector.get<string[]>('roles', context.getHandler());\n      if (!requiredRoles) {\n          return true;\n      }\n      const request = context.switchToHttp().getRequest();\n      const user = request.user;\n  \n      if (!user || !user.rol) {\n          return false; // O manejar según la lógica de tu aplicación\n      }\n  \n      return requiredRoles.some((role) => user.rol.nombre_rol.includes(role));\n  }\n}\n"
        }
      },
      "modules": {
        "auth": {
          "auth.module.ts": "import { Module } from '@nestjs/common';\r\nimport { AuthService } from './auth.service';\r\nimport { UsersService } from './sesion-activa/users.service';\r\nimport { JwtModule } from '@nestjs/jwt';\r\nimport { PassportModule } from '@nestjs/passport';\r\nimport { JwtStrategy } from './jwt.strategy';\r\nimport { RolesGuard } from './roles.guard';\r\nimport { ConfigModule, ConfigService } from '@nestjs/config';\r\n\r\n@Module({\r\n  imports: [\r\n    PassportModule.register({ defaultStrategy: 'jwt' }),\r\n    JwtModule.registerAsync({\r\n      imports: [ConfigModule],\r\n      useFactory: async (configService: ConfigService) => ({\r\n        secret: configService.get<string>('JWT_SECRET'),\r\n        signOptions: { expiresIn: '2d' },\r\n      }),\r\n      inject: [ConfigService],\r\n    }),\r\n    ConfigModule,\r\n  ],\r\n  providers: [AuthService, UsersService, JwtStrategy, RolesGuard],\r\n  exports: [AuthService, UsersService, RolesGuard, JwtModule],\r\n})\r\n\r\nexport class AuthModule {}\r\n",
          "auth.service.ts": "import { Injectable, UnauthorizedException } from '@nestjs/common';\r\nimport { JwtService } from '@nestjs/jwt';\r\nimport { UsersService } from './sesion-activa/users.service';\r\nimport { BadRequestException } from '@nestjs/common';\r\nimport * as bcrypt from 'bcrypt';\r\n\r\n@Injectable()\r\nexport class AuthService {\r\n  constructor(\r\n    private readonly usersService: UsersService,\r\n    private readonly jwtService: JwtService,\r\n  ) {}\r\n\r\n  async validateUser(username: string, pass: string): Promise<any> {\r\n    const user = await this.usersService.findOne(username);\r\n    if (user && await bcrypt.compare(pass, user.password )) {\r\n      const { password, ...result } = user;\r\n      return result;\r\n    }\r\n    throw new UnauthorizedException('Credenciales inválidas');\r\n  }\r\n\r\n  async login(user: any, userAgent: string){\r\n    const payload = { username: user.username, sub: user.userId };\r\n    const token = this.jwtService.sign(payload);\r\n\r\n    //Cerrar sesión anterior si existe (solo cuando el token es diferente)\r\n    const existingUser = await this.usersService.findById(user.userId);\r\n    if (existingUser?. token && existingUser.userAgent !== userAgent ) {\r\n      await this.logout(existingUser.userId);\r\n    }\r\n\r\n    //Actualizar token y userAgent del usuario\r\n    await this.usersService.updateUserToken(user.userId, token, userAgent);\r\n    return { access_token: token};\r\n  }\r\n\r\n  async validateToken(userId: string, token: string): Promise<boolean> {\r\n    const user = await this.usersService.findById(userId);\r\n    if (!user) {\r\n      throw new UnauthorizedException('Usuario no encontrado');\r\n    }\r\n    if (user.token !== token) {\r\n      throw new UnauthorizedException('Sesión caducada');\r\n    }\r\n    return true;\r\n  }\r\n  \r\n  async logout(userId: string): Promise<void> {\r\n    const user = await this.usersService.findById(userId);\r\n    if (!user) return;  // No hacer nada si el usuario no existe\r\n    await this.usersService.updateUserToken(userId, null, null);\r\n  }\r\n}",
          "jwt.strategy.ts": "import { Injectable } from '@nestjs/common';\nimport { PassportStrategy } from '@nestjs/passport';\nimport { ExtractJwt, Strategy } from 'passport-jwt';\nimport { ConfigService } from '@nestjs/config';\n\n@Injectable()\nexport class JwtStrategy extends PassportStrategy(Strategy) {\n  constructor(configService: ConfigService) {\n    super({\n      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),\n      ignoreExpiration: false,\n      secretOrKey: configService.get<string>('JWT_SECRET'),\n    });\n  }\n\n  async validate(payload: any) {\n    return { userId: payload.sub, email: payload.correo, rolesModulos: payload.rolesModulos };\n  }\n}\n",
          "roles.decorator.ts": "import { SetMetadata } from '@nestjs/common';\n\nexport const ROLES_KEY = 'roles';\nexport const Roles = (...roles: { rol: string, modulo: string }[]) => SetMetadata(ROLES_KEY, roles);\n",
          "roles.guard.ts": "import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { JwtService } from '@nestjs/jwt';\nimport { ROLES_KEY } from './roles.decorator';\n\n@Injectable()\nexport class RolesGuard implements CanActivate {\n  constructor(private reflector: Reflector, private jwtService: JwtService) {}\n\n  canActivate(context: ExecutionContext): boolean {\n    const requiredRoles = this.reflector.get<{ rol: string, modulo: string }[]>(ROLES_KEY, context.getHandler());\n    if (!requiredRoles || requiredRoles.length === 0) {\n      return true;\n    }\n\n    const request = context.switchToHttp().getRequest();\n    const authHeader = request.headers.authorization;\n    const bearerToken = authHeader && authHeader.split(' ')[1];\n    \n    if (!bearerToken) {\n      throw new UnauthorizedException('No token provided');\n    }\n\n    try {\n      const tokenPayload = this.jwtService.verify(bearerToken);\n      const userRoles = tokenPayload.rolesModulos;\n\n      const hasRole = requiredRoles.some(requiredRole =>\n        userRoles.some(userRole =>\n          userRole.rol === requiredRole.rol && userRole.modulo === requiredRole.modulo\n        )\n      );\n\n      if (!hasRole) {\n        throw new UnauthorizedException('Insufficient permissions');\n      }\n\n      return true;\n    } catch (error) {\n      throw new UnauthorizedException('Invalid token');\n    }\n  }\n}\n",
          "sesion-activa": {
            "auth.service.spec.ts": "import { Test, TestingModule } from '@nestjs/testing';\r\nimport { AuthService } from '../auth.service';  \r\nimport { UsersService } from './users.service';\r\nimport { JwtService } from '@nestjs/jwt';\r\n\r\ndescribe('AuthService', () => {\r\n  let service: AuthService;\r\n  let usersService: UsersService;\r\n\r\n  beforeEach(async () => {\r\n    const module: TestingModule = await Test.createTestingModule({\r\n      providers: [\r\n        AuthService,\r\n        UsersService,\r\n        {\r\n          provide: JwtService,\r\n          useValue: {\r\n            sign: jest.fn().mockReturnValue('testToken'),\r\n          },\r\n        },\r\n      ],\r\n    }).compile();\r\n\r\n    \r\n    service = module.get<AuthService>(AuthService);\r\n    usersService = module.get<UsersService>(UsersService);\r\n  });\r\n\r\n  it('should be defined', () => {\r\n    expect(service).toBeDefined();\r\n  });\r\n\r\n  it('should validate user credentials', async () => {\r\n    const user = await service.validateUser('user1', 'pass1');\r\n    expect(user).toBeDefined();\r\n    expect(user.username).toBe('user1');\r\n  });\r\n\r\n  it('should throw UnauthorizedException for invalid credentials', async () => {\r\n    await expect(service.validateUser('user1', 'wrongPass')).rejects.toThrow('Credenciales inválidas');\r\n  });\r\n\r\n  it('should login and return a token', async () => {\r\n    const user = { userId: '1', username: 'user1' };\r\n    const result = await service.login(user, 'userAgent1');\r\n    expect(result.access_token).toBe('testToken');\r\n  });\r\n\r\n  it('should validate token', async () => {\r\n    const isValid = await service.validateToken('1', 'testToken');\r\n    expect(isValid).toBe(true);\r\n  });\r\n\r\n  it('should throw UnauthorizedException for invalid token', async () => {\r\n    await expect(service.validateToken('1', 'invalidToken')).rejects.toThrow('Token');\r\n  });\r\n\r\n  it('should logout user', async () => {\r\n    await service.logout('1');\r\n    const user = await usersService.findById('1');\r\n    expect(user.token).toBeNull();\r\n    expect(user.userAgent).toBeNull();\r\n  });\r\n});",
            "sesion-activa.middleware.spec.ts": "import { SesionActivaMiddleware } from './sesion-activa.middleware';\n\ndescribe('SesionActivaMiddleware', () => {\n  it('should be defined', () => {\n    expect(new SesionActivaMiddleware()).toBeDefined();\n  });\n});\n",
            "sesion-activa.middleware.ts": "import { Injectable, NestMiddleware, UnauthorizedException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Repository } from 'typeorm';\nimport { Request, Response, NextFunction } from 'express';\n\n@Injectable()\nexport class SesionActivaMiddleware  {\n  constructor(\n  ) {}\n\n  /* async use(req: Request, res: Response, next: NextFunction) {\n    const authHeader: string | undefined = req.headers['authorization'];\n    const token = authHeader?.startsWith('Bearer ') ? authHeader.slice(7) : undefined;\n\n    if (!token) {\n      throw new UnauthorizedException('Token no proporcionado.');\n    }\n\n    const sesion = await this.sesionRepository.findOne({\n      where: { token, estado: 'activa' },\n    });\n\n    if (!sesion) {\n      throw new UnauthorizedException('Sesión no válida o cerrada.');\n    }\n\n    next();\n  } */\n}\n",
            "users.service.spec.ts": "import { Test, TestingModule } from '@nestjs/testing';\nimport { UsersService } from './users.service';\n\ndescribe('UsersService', () => {\n  let service: UsersService;\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [UsersService],\n    }).compile();\n\n    service = module.get<UsersService>(UsersService);\n  });\n\n  it('should be defined', () => {\n    expect(service).toBeDefined();\n  });\n\n  it('should find a user by username', async () => {\n    const user = await service.findOne('user1');\n    expect(user).toBeDefined();\n    expect(user.username).toBe('user1');\n  });\n\n  it('should find a user by userId', async () => {\n    const user = await service.findById('1');\n    expect(user).toBeDefined();\n    expect(user.userId).toBe('1');\n  });\n\n  it('should update user token and userAgent', async () => {\n    await service.updateUserToken('1', 'newToken', 'newUserAgent');\n    const user = await service.findById('1');\n    expect(user.token).toBe('newToken');\n    expect(user.userAgent).toBe('newUserAgent');\n  });\n});",
            "users.service.ts": "import { Injectable } from '@nestjs/common';\n\n@Injectable()\nexport class UsersService {\n  private users = [\n    // Ejemplo de usuarios\n    { userId: '1', username: 'user1', password: 'pass1', token: null, userAgent: null },\n    { userId: '2', username: 'user2', password: 'pass2', token: null, userAgent: null },\n  ];\n\n  async findOne(username: string) {\n    return this.users.find(user => user.username === username);\n  }\n\n  async findById(userId: string) {\n    return this.users.find(user => user.userId === userId);\n  }\n\n  async updateUserToken(userId: string, token: string, userAgent: string) {\n    const user = await this.findById(userId);\n    if (user) {\n      user.token = token;\n      user.userAgent = userAgent;\n    }\n  }\n}"
          }
        },
        "session": {
          "controllers": {
            "sse.controller.ts": "import { Controller, Get, Req, Res, Logger, Param } from '@nestjs/common';\r\nimport { Request, Response } from 'express';\r\nimport { Observable, Subject, interval } from 'rxjs';\r\nimport { map, takeUntil } from 'rxjs/operators';\r\nimport { SseService } from '../services/sse.service';\r\nimport { JwtService } from '@nestjs/jwt';\r\n\r\n@Controller('api/sse')\r\nexport class SseController {\r\n  private readonly logger = new Logger(SseController.name);\r\n\r\n  constructor(\r\n    private readonly sseService: SseService,\r\n    private readonly jwtService: JwtService\r\n  ) {}\r\n\r\n  @Get('session-events')\r\n  async sessionEvents(@Req() req: Request, @Res() res: Response) {\r\n    // Configurar cabeceras para SSE\r\n    res.setHeader('Content-Type', 'text/event-stream');\r\n    res.setHeader('Cache-Control', 'no-cache');\r\n    res.setHeader('Connection', 'keep-alive');\r\n    res.setHeader('X-Accel-Buffering', 'no'); // Para NGINX\r\n\r\n    // Extraer token de autorización\r\n    let userId = 0; // Usuario anónimo por defecto\r\n    const authHeader = req.headers.authorization;\r\n    \r\n    if (authHeader && authHeader.startsWith('Bearer ')) {\r\n      const token = authHeader.substring(7);\r\n      try {\r\n        const payload = this.jwtService.verify(token);\r\n        userId = payload.sub;\r\n      } catch (error) {\r\n        this.logger.warn(`Token inválido en conexión SSE: ${error.message}`);\r\n      }\r\n    }\r\n\r\n    // Crear flujo de eventos para este cliente\r\n    const client = new Subject<MessageEvent>();\r\n    this.sseService.addClient(userId, client);\r\n    \r\n    // Observable para mantener la conexión viva con heartbeats\r\n    const heartbeat$ = interval(30000).pipe(\r\n      map(() => ({ data: { type: 'heartbeat', timestamp: new Date().toISOString() } } as MessageEvent))\r\n    );\r\n\r\n    // Creación de eventos SSE\r\n    const close$ = new Subject<void>();\r\n    \r\n    // Combinar todos los flujos de eventos\r\n    client.pipe(takeUntil(close$))\r\n      .subscribe(\r\n        (event: MessageEvent) => {\r\n          const data = JSON.stringify(event.data);\r\n          res.write(`data: ${data}\\n\\n`);\r\n        },\r\n        (error) => {\r\n          this.logger.error(`Error en flujo SSE: ${error.message}`);\r\n        },\r\n        () => {\r\n          this.logger.log('Flujo SSE completado');\r\n        }\r\n      );\r\n    \r\n    // Enviar heartbeats para mantener la conexión viva\r\n    heartbeat$.pipe(takeUntil(close$))\r\n      .subscribe(\r\n        (event: MessageEvent) => {\r\n          const data = JSON.stringify(event.data);\r\n          res.write(`data: ${data}\\n\\n`);\r\n        }\r\n      );\r\n\r\n    // Manejar cierre de conexión\r\n    req.on('close', () => {\r\n      this.logger.log(`Conexión SSE cerrada para usuario ${userId}`);\r\n      this.sseService.removeClient(userId, client);\r\n      close$.next();\r\n      close$.complete();\r\n    });\r\n  }\r\n}"
          },
          "entities": {
            "net-session.entity.ts": "import { Entity, Column, PrimaryGeneratedColumn, ManyToOne, JoinColumn, CreateDateColumn } from 'typeorm';\r\nimport { Net_Usuario_Empresa } from '../../usuario/entities/net_usuario_empresa.entity';\r\n\r\n@Entity('NET_SESSION')\r\nexport class Net_Session {\r\n  @PrimaryGeneratedColumn({ name: 'ID_SESSION' })\r\n  id_session: number;\r\n\r\n  @Column({ name: 'TOKEN', length: 500 })\r\n  token: string;\r\n\r\n  @Column({ name: 'REFRESH_TOKEN', length: 500, nullable: true })\r\n  refresh_token: string;\r\n\r\n  @Column({ name: 'USER_AGENT', length: 500 })\r\n  user_agent: string;\r\n\r\n  @Column({ name: 'IP_ADDRESS', length: 50 })\r\n  ip_address: string;\r\n\r\n  @CreateDateColumn({ name: 'FECHA_CREACION' })\r\n  fecha_creacion: Date;\r\n\r\n  @Column({ name: 'FECHA_EXPIRACION' })\r\n  fecha_expiracion: Date;\r\n\r\n  @Column({ name: 'ULTIMA_ACTIVIDAD', default: () => 'CURRENT_TIMESTAMP' })\r\n  ultima_actividad: Date;\r\n\r\n  @Column({ \r\n    name: 'ESTADO', \r\n    length: 20,\r\n    default: 'ACTIVA',\r\n    type: 'varchar'\r\n  })\r\n  estado: 'ACTIVA' | 'EXPIRADA' | 'REVOCADA' | 'CERRADA';\r\n\r\n  @ManyToOne(() => Net_Usuario_Empresa, { onDelete: 'CASCADE' })\r\n  @JoinColumn({ name: 'ID_USUARIO_EMPRESA' })\r\n  usuario_empresa: Net_Usuario_Empresa;\r\n}"
          },
          "interfaces": {
            "auth-data.interface.ts": "export interface AuthData {\r\n  token: string;\r\n  refreshToken: string;\r\n  userAgent: string;\r\n  ipAddress: string;\r\n}"
          },
          "services": {
            "session.service.ts": "import { Injectable, Logger, UnauthorizedException } from '@nestjs/common';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { Repository, LessThan } from 'typeorm';\r\nimport { JwtService } from '@nestjs/jwt';\r\nimport { Net_Session } from '../entities/net-session.entity';\r\nimport { AuthData } from '../interfaces/auth-data.interface';\r\nimport { SseService } from './sse.service';\r\nimport { addDays } from 'date-fns';\r\n\r\n@Injectable()\r\nexport class SessionService {\r\n  private readonly logger = new Logger(SessionService.name);\r\n\r\n  constructor(\r\n    @InjectRepository(Net_Session)\r\n    private readonly sessionRepository: Repository<Net_Session>,\r\n    private readonly jwtService: JwtService,\r\n    private readonly sseService: SseService,\r\n  ) {\r\n    // Iniciar limpieza de sesiones expiradas\r\n    this.cleanupExpiredSessions();\r\n  }\r\n\r\n  async createSession(userId: number, authData: AuthData): Promise<Net_Session> {\r\n    // Crear nueva sesión\r\n    const session = this.sessionRepository.create({\r\n      token: authData.token,\r\n      refresh_token: authData.refreshToken,\r\n      user_agent: authData.userAgent,\r\n      ip_address: authData.ipAddress,\r\n      fecha_expiracion: addDays(new Date(), 1),\r\n      estado: 'ACTIVA',\r\n      usuario_empresa: { id_usuario_empresa: userId },\r\n    });\r\n\r\n    return this.sessionRepository.save(session);\r\n  }\r\n\r\n  async invalidatePreviousSessions(userId: number): Promise<void> {\r\n    const activeSessions = await this.sessionRepository.find({\r\n      where: {\r\n        usuario_empresa: { id_usuario_empresa: userId },\r\n        estado: 'ACTIVA',\r\n      },\r\n    });\r\n\r\n    if (activeSessions.length > 0) {\r\n      await this.sessionRepository.update(\r\n        activeSessions.map(session => session.id_session),\r\n        { estado: 'REVOCADA' }\r\n      );\r\n\r\n      // Notificar a los clientes conectados sobre la invalidación\r\n      activeSessions.forEach(session => {\r\n        this.sseService.emitToUser(userId, {\r\n          type: 'session-invalidated',\r\n          message: 'Tu sesión ha sido cerrada porque se ha iniciado sesión en otro dispositivo',\r\n          sessionId: session.id_session,\r\n        });\r\n      });\r\n    }\r\n  }\r\n\r\n  async validateSession(token: string): Promise<boolean> {\r\n    try {\r\n      // Verificar el token JWT\r\n      const payload = this.jwtService.verify(token);\r\n      \r\n      // Buscar la sesión\r\n      const session = await this.sessionRepository.findOne({\r\n        where: { token, estado: 'ACTIVA' },\r\n        relations: ['usuario_empresa'],\r\n      });\r\n\r\n      if (!session) {\r\n        return false;\r\n      }\r\n\r\n      // Verificar si la sesión ha expirado\r\n      if (session.fecha_expiracion < new Date()) {\r\n        await this.updateSessionStatus(session.id_session, 'EXPIRADA');\r\n        return false;\r\n      }\r\n\r\n      // Actualizar última actividad\r\n      await this.updateLastActivity(session.id_session);\r\n      return true;\r\n    } catch (error) {\r\n      this.logger.error(`Error validando sesión: ${error.message}`);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  async updateLastActivity(sessionId: number): Promise<void> {\r\n    await this.sessionRepository.update(\r\n      { id_session: sessionId },\r\n      { ultima_actividad: new Date() }\r\n    );\r\n  }\r\n\r\n  async refreshToken(refreshToken: string): Promise<{ token: string, refreshToken: string }> {\r\n    const session = await this.sessionRepository.findOne({\r\n      where: { refresh_token: refreshToken, estado: 'ACTIVA' },\r\n      relations: ['usuario_empresa'],\r\n    });\r\n\r\n    if (!session) {\r\n      throw new UnauthorizedException('Token de actualización inválido');\r\n    }\r\n\r\n    // Generar nuevos tokens\r\n    const payload = {\r\n      sub: session.usuario_empresa.id_usuario_empresa,\r\n    };\r\n    const newToken = this.jwtService.sign(payload, { expiresIn: '24h' });\r\n    const newRefreshToken = this.jwtService.sign({}, { expiresIn: '7d' });\r\n\r\n    // Actualizar sesión\r\n    session.token = newToken;\r\n    session.refresh_token = newRefreshToken;\r\n    session.ultima_actividad = new Date();\r\n    session.fecha_expiracion = addDays(new Date(), 1);\r\n    await this.sessionRepository.save(session);\r\n\r\n    return { token: newToken, refreshToken: newRefreshToken };\r\n  }\r\n\r\n  async updateSessionStatus(sessionId: number, status: 'ACTIVA' | 'EXPIRADA' | 'REVOCADA' | 'CERRADA'): Promise<void> {\r\n    await this.sessionRepository.update(\r\n      { id_session: sessionId },\r\n      { estado: status }\r\n    );\r\n  }\r\n\r\n  private async cleanupExpiredSessions(): Promise<void> {\r\n    try {\r\n      // Marcar sesiones expiradas\r\n      const result = await this.sessionRepository.update(\r\n        {\r\n          fecha_expiracion: LessThan(new Date()),\r\n          estado: 'ACTIVA',\r\n        },\r\n        { estado: 'EXPIRADA' }\r\n      );\r\n\r\n      this.logger.log(`Sesiones expiradas marcadas: ${result.affected}`);\r\n\r\n      // Programar la próxima limpieza en una hora\r\n      setTimeout(() => this.cleanupExpiredSessions(), 3600000);\r\n    } catch (error) {\r\n      this.logger.error(`Error durante la limpieza de sesiones: ${error.message}`);\r\n      // Reintentar en 5 minutos en caso de error\r\n      setTimeout(() => this.cleanupExpiredSessions(), 300000);\r\n    }\r\n  }\r\n\r\n  async getActiveSessionByUserId(userId: number): Promise<Net_Session[]> {\r\n    return this.sessionRepository.find({\r\n      where: {\r\n        usuario_empresa: { id_usuario_empresa: userId },\r\n        estado: 'ACTIVA',\r\n      },\r\n    });\r\n  }\r\n}",
            "sse.service.ts": "import { Injectable, Logger } from '@nestjs/common';\r\nimport { Subject } from 'rxjs';\r\n\r\ninterface SessionEvent {\r\n  type: string;\r\n  message?: string;\r\n  [key: string]: any;\r\n}\r\n\r\n@Injectable()\r\nexport class SseService {\r\n  private readonly logger = new Logger(SseService.name);\r\n  private clients: Map<number, Subject<MessageEvent>[]> = new Map();\r\n  private globalEvents = new Subject<MessageEvent>();\r\n\r\n  addClient(userId: number, client: Subject<MessageEvent>): void {\r\n    if (!this.clients.has(userId)) {\r\n      this.clients.set(userId, []);\r\n    }\r\n    this.clients.get(userId).push(client);\r\n    this.logger.log(`Cliente conectado para usuario ${userId}. Total clientes: ${this.clients.get(userId).length}`);\r\n  }\r\n\r\n  removeClient(userId: number, client: Subject<MessageEvent>): void {\r\n    const userClients = this.clients.get(userId) || [];\r\n    const index = userClients.indexOf(client);\r\n    \r\n    if (index !== -1) {\r\n      userClients.splice(index, 1);\r\n      this.logger.log(`Cliente desconectado para usuario ${userId}. Clientes restantes: ${userClients.length}`);\r\n      \r\n      if (userClients.length === 0) {\r\n        this.clients.delete(userId);\r\n      }\r\n    }\r\n  }\r\n\r\n  emitToUser(userId: number, data: SessionEvent): void {\r\n    const userClients = this.clients.get(userId) || [];\r\n    const event = { data } as MessageEvent;\r\n    \r\n    userClients.forEach(client => {\r\n      try {\r\n        client.next(event);\r\n      } catch (error) {\r\n        this.logger.error(`Error al emitir evento al usuario ${userId}: ${error.message}`);\r\n      }\r\n    });\r\n  }\r\n\r\n  emitToAll(data: SessionEvent): void {\r\n    const event = { data } as MessageEvent;\r\n    this.globalEvents.next(event);\r\n    \r\n    // También enviar a todos los clientes específicos\r\n    this.clients.forEach((clients, userId) => {\r\n      clients.forEach(client => {\r\n        try {\r\n          client.next(event);\r\n        } catch (error) {\r\n          this.logger.error(`Error al emitir evento global al usuario ${userId}: ${error.message}`);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  getGlobalEventStream() {\r\n    return this.globalEvents.asObservable();\r\n  }\r\n}\r\n"
          },
          "session.module.ts": "import { Module } from '@nestjs/common';\r\nimport { TypeOrmModule } from '@nestjs/typeorm';\r\nimport { JwtModule } from '@nestjs/jwt';\r\nimport { Net_Session } from './entities/net-session.entity';\r\nimport { SessionService } from './services/session.service';\r\nimport { SseController } from './controllers/sse.controller';\r\nimport { SseService } from './services/sse.service';\r\n\r\n@Module({\r\n  imports: [\r\n    TypeOrmModule.forFeature([Net_Session]),\r\n    JwtModule.register({\r\n      secret: process.env.JWT_SECRET || 'secretKey',\r\n      signOptions: { expiresIn: '24h' },\r\n    }),\r\n  ],\r\n  providers: [SessionService, SseService],\r\n  controllers: [SseController],\r\n  exports: [SessionService, SseService],\r\n})\r\nexport class SessionModule {}\r\n"
        },
        "usuario": {
          "entities": {
            "net_modulo.entity.ts": "import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, JoinColumn, OneToMany } from 'typeorm';\nimport { net_rol_modulo } from './net_rol_modulo.entity';\nimport { Net_Centro_Trabajo } from 'src/modules/Empresarial/entities/net_centro_trabajo.entity';\nimport { net_usuario_modulo } from './net_usuario_modulo.entity';\n\n@Entity({ name: 'NET_MODULO' })\nexport class net_modulo {\n  @PrimaryGeneratedColumn({ type: 'int', name: 'ID_MODULO', primaryKeyConstraintName: 'PK_id_modulo' })\n  id_modulo: number;\n\n  @Column('varchar2', { length: 100, name: 'NOMBRE' })\n  nombre: string;\n\n  @Column('varchar2', { length: 255, name: 'DESCRIPCION', nullable: true })\n  descripcion: string;\n\n  @ManyToOne(() => Net_Centro_Trabajo, centroTrabajo => centroTrabajo.modulos, { nullable: false })\n  @JoinColumn({ name: 'ID_CENTRO_TRABAJO', referencedColumnName: 'id_centro_trabajo', foreignKeyConstraintName: 'FK_id_centro_trabajo_modulo' })\n  centroTrabajo: Net_Centro_Trabajo;\n\n  @OneToMany(() => net_rol_modulo, rolModulo => rolModulo.modulo)\n  roles: net_rol_modulo[];\n\n  @OneToMany(() => net_usuario_modulo, usuarioModulo => usuarioModulo.rolModulo)\n  usuarios: net_usuario_modulo[];\n}\n",
            "Net_Rol_Modulo.entity.ts": "import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, OneToMany, JoinColumn } from 'typeorm';\nimport { net_modulo } from './net_modulo.entity';\nimport { net_usuario_modulo } from './net_usuario_modulo.entity';\n\n@Entity({ name: 'NET_ROL_MODULO' })\nexport class net_rol_modulo {\n  @PrimaryGeneratedColumn({ type: 'int', name: 'ID_ROL_MODULO', primaryKeyConstraintName: 'PK_id_rol_modulo' })\n  id_rol_modulo: number;\n\n  @Column('varchar2', { length: 50, name: 'NOMBRE' })\n  nombre: string;\n\n  @Column('varchar2', { length: 255, name: 'DESCRIPCION', nullable: true })\n  descripcion: string;\n\n  @ManyToOne(() => net_modulo, modulo => modulo.roles, { nullable: false })\n  @JoinColumn({ name: 'ID_MODULO', referencedColumnName: 'id_modulo', foreignKeyConstraintName: 'FK_id_modulo_rol_modulo' })\n  modulo: net_modulo;\n\n  @OneToMany(() => net_usuario_modulo, usuarioModulo => usuarioModulo.rolModulo)\n  usuarios: net_usuario_modulo[];\n}\n",
            "net_seguridad.entity.ts": "import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, JoinColumn } from 'typeorm';\nimport { Net_Usuario_Empresa } from './net_usuario_empresa.entity';\n\n@Entity({ name: 'NET_SEGURIDAD' })\nexport class Net_Seguridad {\n  @PrimaryGeneratedColumn({ type: 'int', name: 'ID_SEGURIDAD', primaryKeyConstraintName: 'PK_id_seguridad' })\n  id_seguridad: number;\n\n  @Column('varchar2', { length: 100, name: 'PREGUNTA' })\n  pregunta: string;\n\n  @Column('varchar2', { length: 100, name: 'RESPUESTA' })\n  respuesta: string;\n  \n  @ManyToOne(() => Net_Usuario_Empresa, usuarioEmpresa => usuarioEmpresa.seguridad, { nullable: false })\n  @JoinColumn({ name: 'ID_USUARIO_EMPRESA', referencedColumnName: 'id_usuario_empresa', foreignKeyConstraintName: 'FK_id_usuario_empresa_seguridad' })\n  usuarioEmpresa: Net_Usuario_Empresa;\n}\n",
            "net_usuario_empresa.entity.ts": "import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, OneToMany, ManyToOne, JoinColumn } from 'typeorm';\r\nimport { Net_Seguridad } from './net_seguridad.entity';\r\nimport { net_usuario_modulo } from './net_usuario_modulo.entity';\r\nimport { Net_Empleado_Centro_Trabajo } from 'src/modules/Empresarial/entities/net_empleado_centro_trabajo.entity';\r\nimport { net_detalle_persona } from 'src/modules/Persona/entities/net_detalle_persona.entity';\r\n\r\n@Entity({ name: 'NET_USUARIO_EMPRESA' })\r\nexport class Net_Usuario_Empresa {\r\n  @PrimaryGeneratedColumn({ type: 'int', name: 'ID_USUARIO_EMPRESA', primaryKeyConstraintName: 'PK_id_usuario_empresa' })\r\n  id_usuario_empresa: number;\r\n\r\n  @Column('varchar2', { length: 50, default: 'INACTIVO', name: 'ESTADO' })\r\n  estado: string;\r\n\r\n  @Column('varchar2', { length: 200, nullable: false, name: 'CONTRASENA' })\r\n  contrasena: string;\r\n\r\n  @Column({ type: 'number', default: 0, name: 'ACCESO_TODOS_MODULOS' })\r\n  acceso_todos_modulos: number;\r\n\r\n  @CreateDateColumn({ type: 'timestamp', name: 'FECHA_CREACION' })\r\n  fecha_creacion: Date;\r\n\r\n  @Column({ type: 'timestamp', nullable: true, name: 'FECHA_VERIFICACION' })\r\n  fecha_verificacion: Date;\r\n\r\n  @UpdateDateColumn({ type: 'timestamp', name: 'FECHA_MODIFICACION' })\r\n  fecha_modificacion: Date;\r\n\r\n  @Column({ type: 'timestamp', nullable: true, name: 'FECHA_DESACTIVACION' })\r\n  fecha_desactivacion: Date;\r\n\r\n  @Column({ type: 'timestamp', nullable: true, name: 'FECHA_REACTIVACION' })\r\n  fecha_reactivacion: Date;\r\n\r\n  @OneToMany(() => Net_Seguridad, seguridad => seguridad.usuarioEmpresa)\r\n  seguridad: Net_Seguridad[];\r\n\r\n  @Column('varchar2', { length: 500, nullable: true, name: 'REFRESH_TOKEN' })\r\n  refreshToken: string;\r\n\r\n  @OneToMany(() => net_usuario_modulo, usuarioModulo => usuarioModulo.usuarioEmpresa)\r\n  usuarioModulos: net_usuario_modulo[];\r\n\r\n  @ManyToOne(() => Net_Empleado_Centro_Trabajo, empleadoCentroTrabajo => empleadoCentroTrabajo.usuarioEmpresas, { nullable: false })\r\n  @JoinColumn({ name: 'ID_EMPLEADO_CENTRO_TRABAJO', referencedColumnName: 'id_empleado_centro_trabajo', foreignKeyConstraintName: 'FK_id_empleado_centro_trabajo_usuario_empresa' })\r\n  empleadoCentroTrabajo: Net_Empleado_Centro_Trabajo;\r\n\r\n  @OneToMany(() => net_detalle_persona, detallePersona => detallePersona.usuarioEmpresa)\r\n  detallePersonas: net_detalle_persona[];\r\n}\r\n",
            "Net_Usuario_Modulo.entity.ts": "import { Entity, PrimaryGeneratedColumn, ManyToOne, JoinColumn } from 'typeorm';\nimport { Net_Usuario_Empresa } from './net_usuario_empresa.entity';\nimport { net_rol_modulo } from './net_rol_modulo.entity';\n\n@Entity({ name: 'NET_USUARIO_MODULO' })\nexport class net_usuario_modulo {\n  @PrimaryGeneratedColumn({ type: 'int', name: 'ID_USUARIO_MODULO', primaryKeyConstraintName: 'PK_id_usuario_modulo' })\n  id_usuario_modulo: number;\n\n  @ManyToOne(() => Net_Usuario_Empresa, usuarioEmpresa => usuarioEmpresa.usuarioModulos, { nullable: false })\n  @JoinColumn({ name: 'ID_USUARIO_EMPRESA', referencedColumnName: 'id_usuario_empresa', foreignKeyConstraintName: 'FK_id_usuario_empresa_usuario_modulo' })\n  usuarioEmpresa: Net_Usuario_Empresa;\n\n  @ManyToOne(() => net_rol_modulo, rolModulo => rolModulo.usuarios, { nullable: false })\n  @JoinColumn({ name: 'ID_ROL_MODULO', referencedColumnName: 'id_rol_modulo', foreignKeyConstraintName: 'FK_id_rol_modulo_usuario_modulo' })\n  rolModulo: net_rol_modulo;\n}\n"
          },
          "usuario.controller.ts": "import { Controller, Get, Post, Body, Patch, Param, Delete, Query, UseGuards, BadRequestException, HttpCode, HttpStatus, Req, UseInterceptors, ParseIntPipe, Res, Put, UploadedFiles, NotFoundException, Logger, UsePipes, ValidationPipe } from '@nestjs/common';\r\nimport { UsuarioService } from './usuario.service';\r\nimport { UpdateUsuarioDto } from './dto/update-usuario.dto';\r\nimport { PaginationDto } from 'src/common/dtos/pagination.dto';\r\nimport { ApiTags } from '@nestjs/swagger';\r\nimport { FileFieldsInterceptor } from '@nestjs/platform-express';\r\nimport { CreatePreRegistroDto } from './dto/create-pre-registro.dto';\r\nimport { CompleteRegistrationDto } from './dto/complete-registration.dto';\r\nimport { LoginDto } from './dto/login.dto';\r\nimport { Net_Usuario_Empresa } from './entities/net_usuario_empresa.entity';\r\nimport { net_rol_modulo } from './entities/net_rol_modulo.entity';\r\nimport { net_modulo } from './entities/net_modulo.entity';\r\nimport { ResetPasswordDto } from './dto/reset-password.dto';\r\n\r\n@ApiTags('usuario')\r\n@Controller('usuario')\r\nexport class UsuarioController {\r\n  private readonly logger = new Logger(UsuarioController.name);\r\n  constructor(private readonly usuarioService: UsuarioService) { }\r\n\r\n  @Post('preregistro-masivo')\r\n  @UsePipes(new ValidationPipe({ whitelist: true, forbidNonWhitelisted: true }))\r\n  async preRegistroMasivo(@Body() createPreRegistroDtos: CreatePreRegistroDto[]): Promise<void> {\r\n    return this.usuarioService.preRegistroMasivo(createPreRegistroDtos);\r\n  }\r\n\r\n  @Post('login')\r\n  async login(@Body() loginDto: LoginDto) {\r\n    return this.usuarioService.login(loginDto);\r\n  }\r\n\r\n  @Post('logout')\r\n  async logout(@Req() req: Request, @Res() res: Response) {\r\n    return this.usuarioService.logout(req, res);\r\n  }\r\n\r\n  @Patch(':id/desactivar')\r\n  async desactivarUsuario(\r\n    @Param('id') idUsuario: number,\r\n    @Body('fechaReactivacion') fechaReactivacion: Date | null = null,\r\n  ) {\r\n    await this.usuarioService.desactivarUsuario(idUsuario, fechaReactivacion);\r\n    return { message: 'Usuario desactivado correctamente' };\r\n  }\r\n\r\n  @Patch(':id/reactivar')\r\n  async reactivarUsuario(@Param('id') idUsuario: number) {\r\n    await this.usuarioService.reactivarUsuario(idUsuario);\r\n    return { message: 'Usuario reactivado correctamente' };\r\n  }\r\n\r\n  @Post('preregistro')\r\n  async preRegistro(@Body() createPreRegistroDto: CreatePreRegistroDto): Promise<void> {\r\n    return this.usuarioService.preRegistro(createPreRegistroDto);\r\n  }\r\n\r\n  @Post('preregistro-admin')\r\n  async preRegistroAdmin(@Body() createPreRegistroDto: CreatePreRegistroDto): Promise<void> {\r\n    return this.usuarioService.preRegistroAdmin(createPreRegistroDto);\r\n  }\r\n\r\n  @Post('completar-registro')\r\n  @UseInterceptors(\r\n    FileFieldsInterceptor([\r\n      { name: 'archivo_identificacion', maxCount: 1 },\r\n      { name: 'foto_empleado', maxCount: 1 }\r\n    ])\r\n  )\r\n  \r\n  async completarRegistro(\r\n    @Query('token') token: string,\r\n    @Body('datos') datos: string,\r\n    @UploadedFiles() files: { archivo_identificacion?: Express.Multer.File[], foto_empleado?: Express.Multer.File[] },\r\n    ): Promise<void> {\r\n      const completeRegistrationDto: CompleteRegistrationDto = JSON.parse(datos);\r\n      const archivoIdentificacionBuffer = files?.archivo_identificacion?.[0]?.buffer || null;\r\n      const fotoEmpleadoBuffer = files?.foto_empleado?.[0]?.buffer || null;\r\n      return this.usuarioService.completarRegistro(token, completeRegistrationDto, archivoIdentificacionBuffer, fotoEmpleadoBuffer);\r\n  }\r\n\r\n  @Get('perfil')\r\n  async obtenerPerfilUsuario(@Query('correo') correo: string) {\r\n  return this.usuarioService.obtenerPerfilPorCorreo(correo);\r\n}\r\n\r\n@Patch('actualizar-informacion-empleado/:id')\r\n  @UseInterceptors(FileFieldsInterceptor([\r\n    { name: 'archivo_identificacion', maxCount: 1 },\r\n    { name: 'foto_empleado', maxCount: 1 }\r\n  ]))\r\n  async actualizarInformacionEmpleado(\r\n    @Param('id') id: number,\r\n    @UploadedFiles() files: { archivo_identificacion?: Express.Multer.File[], foto_empleado?: Express.Multer.File[] },\r\n    @Body() updateEmpleadoParcialDto: any\r\n  ) {\r\n    const archivoIdentificacionBuffer = files?.archivo_identificacion?.[0]?.buffer || null;\r\n    const fotoEmpleadoBuffer = files?.foto_empleado?.[0]?.buffer || null;\r\n    if (!updateEmpleadoParcialDto.nombreEmpleado && !updateEmpleadoParcialDto.telefono_1 && !updateEmpleadoParcialDto.telefono_2 && !archivoIdentificacionBuffer && !fotoEmpleadoBuffer) {\r\n      throw new BadRequestException('No se han proporcionado datos para actualizar.');\r\n    }\r\n    return this.usuarioService.actualizarEmpleado(+id, updateEmpleadoParcialDto, archivoIdentificacionBuffer, fotoEmpleadoBuffer);\r\n  }\r\n\r\n  @Put('cambiar-contrasena')\r\n  async cambiarContrasena(@Body() cambiarContrasenaDto: { correo: string; nuevaContrasena: string }) {\r\n    return this.usuarioService.cambiarContrasena(cambiarContrasenaDto.correo, cambiarContrasenaDto.nuevaContrasena);\r\n  }\r\n\r\n  @Get('roles')\r\n  async getRolesByEmpresa(@Query() query: any) {\r\n    return this.usuarioService.getRolesPorEmpresa(query.idEmpresa);\r\n  }\r\n\r\n  @Get('modulo-centro-trabajo')\r\n  async obtenerUsuariosPorModuloYCentroTrabajo(\r\n    @Query('modulos') modulos: string[],\r\n    @Query('idCentroTrabajo') idCentroTrabajo: number\r\n  ): Promise<Net_Usuario_Empresa[]> {\r\n    if (typeof modulos === 'string') {\r\n      modulos = [modulos];\r\n    }\r\n    try {\r\n      return await this.usuarioService.obtenerUsuariosPorModuloYCentroTrabajo(modulos, idCentroTrabajo);\r\n    } catch (error) {\r\n      console.error('Error al obtener usuarios por módulo y centro de trabajo:', error);\r\n      throw new Error('Ocurrió un error inesperado. Inténtelo de nuevo más tarde o contacte con soporte si el problema persiste.');\r\n    }\r\n  }\r\n\r\n  @Get('roles-modulos/:modulo')\r\n  async obtenerRolesPorModulo(@Param('modulo') modulo: string): Promise<net_rol_modulo[]> {\r\n    return this.usuarioService.obtenerRolesPorModulo(modulo);\r\n  }\r\n\r\n  @Get('modulos-centro-trabajo/:idCentroTrabajo')\r\n  async obtenerModulosPorCentroTrabajo(\r\n    @Param('idCentroTrabajo', ParseIntPipe) idCentroTrabajo: number,\r\n  ): Promise<net_modulo[]> {\r\n    return this.usuarioService.obtenerModulosPorCentroTrabajo(idCentroTrabajo);\r\n  }\r\n\r\n  /* @Get('roles')\r\n  async getAllRolesExceptAdmin(): Promise<Net_Rol[]> {\r\n    return this.usuarioService.findAllRolesExceptAdmin();\r\n  } */\r\n\r\n\r\n@Get('centro/:centroTrabajoId')\r\n  async getUsuariosPorCentro(\r\n    @Param('centroTrabajoId', ParseIntPipe) centroTrabajoId: number,\r\n    @Res() res,\r\n  ): Promise<Response> {\r\n    try {\r\n      const usuarios: any = await this.usuarioService.getUsuariosPorCentro(centroTrabajoId);\r\n      return res.status(HttpStatus.OK).json(usuarios);\r\n    } catch (error) {\r\n      return res.status(HttpStatus.INTERNAL_SERVER_ERROR).json({\r\n        statusCode: HttpStatus.INTERNAL_SERVER_ERROR,\r\n        message: 'Error fetching users for the specified center',\r\n        error: error.message,\r\n      });\r\n    }\r\n  }\r\n  \r\n  /* @Post('auth/login')\r\n  async login(@Body() loginDto: CreateUsuarioDto) {\r\n    return this.usuarioService.login(loginDto.correo, loginDto.contrasena);\r\n  } */\r\n\r\n  @Get()\r\n  findAll(@Query() paginationDto: PaginationDto) {\r\n    return this.usuarioService.findAll(paginationDto);\r\n  }\r\n\r\n  @Get(':id')\r\n  findOne(@Param('id') id: string) {\r\n    return this.usuarioService.findOne(+id);\r\n  }\r\n\r\n  @Patch('auth/confirm')\r\n  update(@Body() updateUsuarioDto: UpdateUsuarioDto) {\r\n    return this.usuarioService.update(updateUsuarioDto);\r\n  }\r\n\r\n  @Delete(':id')\r\n  remove(@Param('id') id: string) {\r\n    return this.usuarioService.remove(+id);\r\n  }\r\n\r\n  @Post('olvido-contrasena')\r\n  async olvidoContrasena(@Body() dto: any): Promise<void> {\r\n    const usuario = await this.usuarioService.buscarUsuarioPorCorreo(dto.email);\r\n    if (!usuario) {\r\n      throw new NotFoundException('Usuario no encontrado');\r\n    }\r\n    const token = await this.usuarioService.crearTokenRestablecimiento(usuario);\r\n    await this.usuarioService.enviarCorreoRestablecimiento(usuario.empleadoCentroTrabajo.correo_1, token);\r\n  }\r\n\r\n  @Post('restablecer-contrasena/:token')\r\n  async restablecerContrasena(\r\n    @Param('token') token: string,\r\n    @Body() dto: ResetPasswordDto,\r\n  ): Promise<{ message: string }> {\r\n    await this.usuarioService.restablecerContrasena(token, dto.nuevaContrasena);\r\n    return { message: 'Contraseña restablecida correctamente' };\r\n  }\r\n}",
          "usuario.module.ts": "import { Module } from '@nestjs/common';\nimport { UsuarioService } from './usuario.service';\nimport { UsuarioController } from './usuario.controller';\nimport { TypeOrmModule } from '@nestjs/typeorm';\nimport { CommonModule } from 'src/common/common.module';\nimport { Net_Tipo_Identificacion } from '../tipo_identificacion/entities/net_tipo_identificacion.entity';\nimport { Net_Centro_Trabajo } from '../Empresarial/entities/net_centro_trabajo.entity';\nimport { MailService } from 'src/common/services/mail.service';\nimport { Net_Seguridad } from './entities/net_seguridad.entity';\nimport { net_modulo } from './entities/net_modulo.entity';\nimport { net_rol_modulo } from './entities/net_rol_modulo.entity';\nimport { Net_Usuario_Empresa } from './entities/net_usuario_empresa.entity';\nimport { net_usuario_modulo } from './entities/net_usuario_modulo.entity';\nimport { AuthModule } from '../auth/auth.module';\nimport { Net_Empleado_Centro_Trabajo } from '../Empresarial/entities/net_empleado_centro_trabajo.entity';\nimport { Net_Empleado } from '../Empresarial/entities/net_empleado.entity';\n\n@Module({\n  controllers: [UsuarioController],\n  providers: [UsuarioService, MailService],\n  imports: [\n    TypeOrmModule.forFeature([\n      Net_Empleado, \n      Net_Tipo_Identificacion,\n      Net_Centro_Trabajo,\n      Net_Seguridad,\n      Net_Empleado_Centro_Trabajo,\n      net_rol_modulo,\n      net_modulo,\n      Net_Usuario_Empresa,\n      net_usuario_modulo,\n    ]),\n    CommonModule,\n    AuthModule\n  ]\n})\nexport class UsuarioModule {}\n",
          "usuario.service.ts": "import { BadRequestException, Injectable, InternalServerErrorException, Logger, NotFoundException, UnauthorizedException } from '@nestjs/common';\r\nimport { UpdateUsuarioDto } from './dto/update-usuario.dto';\r\nimport { InjectRepository } from '@nestjs/typeorm';\r\nimport { PaginationDto } from 'src/common/dtos/pagination.dto';\r\nimport { LessThan, Repository } from 'typeorm';\r\nimport { JwtService } from '@nestjs/jwt';\r\nimport { MailService } from 'src/common/services/mail.service';\r\nimport * as bcrypt from 'bcrypt';\r\nimport { CreatePreRegistroDto } from './dto/create-pre-registro.dto';\r\nimport { CompleteRegistrationDto } from './dto/complete-registration.dto';\r\nimport { LoginDto } from './dto/login.dto';\r\nimport { net_rol_modulo } from './entities/net_rol_modulo.entity';\r\nimport { Net_Usuario_Empresa } from './entities/net_usuario_empresa.entity';\r\nimport { net_usuario_modulo } from './entities/net_usuario_modulo.entity';\r\nimport { net_modulo } from './entities/net_modulo.entity';\r\nimport { Cron } from '@nestjs/schedule';\r\nimport { Net_Empleado } from '../Empresarial/entities/net_empleado.entity';\r\nimport { Net_Empleado_Centro_Trabajo } from '../Empresarial/entities/net_empleado_centro_trabajo.entity';\r\nimport * as fs from 'fs';\r\nimport * as path from 'path';\r\n\r\n@Injectable()\r\nexport class UsuarioService {\r\n  private readonly logger = new Logger(UsuarioService.name)\r\n\r\n  constructor(\r\n    @InjectRepository(Net_Empleado)\r\n    private readonly empleadoRepository: Repository<Net_Empleado>,\r\n    private readonly jwtService: JwtService,\r\n    private readonly mailService: MailService,\r\n    @InjectRepository(Net_Empleado_Centro_Trabajo)\r\n    private readonly empleadoCentroTrabajoRepository: Repository<Net_Empleado_Centro_Trabajo>,\r\n    @InjectRepository(Net_Usuario_Empresa)\r\n    private readonly usuarioEmpresaRepository: Repository<Net_Usuario_Empresa>,\r\n    @InjectRepository(net_rol_modulo)\r\n    private readonly rolModuloRepository: Repository<net_rol_modulo>,\r\n    @InjectRepository(net_usuario_modulo)\r\n    private readonly usuarioModuloRepository: Repository<net_usuario_modulo>,\r\n    @InjectRepository(net_modulo)\r\n    private readonly moduloRepository: Repository<net_modulo>,\r\n  ) { }\r\n\r\n  async login(loginDto: LoginDto) {\r\n    const { correo, contrasena } = loginDto;\r\n    const usuario = await this.usuarioEmpresaRepository.findOne({\r\n      where: {\r\n        empleadoCentroTrabajo: {\r\n          correo_1: correo,\r\n        },\r\n      },\r\n      relations: [\r\n        'empleadoCentroTrabajo',\r\n        'empleadoCentroTrabajo.empleado',\r\n        'empleadoCentroTrabajo.centroTrabajo',\r\n        'usuarioModulos',\r\n        'usuarioModulos.rolModulo',\r\n        'usuarioModulos.rolModulo.modulo',\r\n      ],\r\n    });\r\n  \r\n    if (!usuario) {\r\n      throw new UnauthorizedException('Credenciales inválidas');\r\n    }\r\n  \r\n    if (usuario.usuarioModulos.length === 0) {\r\n      throw new UnauthorizedException('No tiene roles asignados a ese usuario.');\r\n    }\r\n  \r\n    const isPasswordValid = await bcrypt.compare(contrasena, usuario.contrasena);\r\n    if (!isPasswordValid) {\r\n      throw new UnauthorizedException('Credenciales inválidas');\r\n    }\r\n  \r\n    const rolesModulos = usuario.usuarioModulos.map((um) => ({\r\n      rol: um.rolModulo.nombre,\r\n      modulo: um.rolModulo.modulo.nombre,\r\n    }));\r\n  \r\n    const nombreEmpleado = usuario.empleadoCentroTrabajo.empleado?.nombreEmpleado || 'No disponible';\r\n  \r\n    const payload = {\r\n      correo,\r\n      sub: usuario.id_usuario_empresa,\r\n      rolesModulos,\r\n      idCentroTrabajo: usuario.empleadoCentroTrabajo.centroTrabajo.id_centro_trabajo,\r\n      departamento: usuario.empleadoCentroTrabajo.departamento,\r\n      numero_empleado: usuario.empleadoCentroTrabajo.numeroEmpleado,\r\n      municipio: usuario.empleadoCentroTrabajo.municipio,\r\n      nombrePuesto: usuario.empleadoCentroTrabajo.nombrePuesto,\r\n      nombreEmpleado,\r\n    };\r\n  \r\n    const accessToken = this.jwtService.sign(payload, { expiresIn: '100d' });\r\n  \r\n    return { accessToken };\r\n  }\r\n  \r\n  async logout(req, res) {\r\n    return res.json({ message: 'Sesión cerrada' });\r\n  }\r\n\r\n  async obtenerPerfilPorCorreo(correo: string) {\r\n    const usuario = await this.usuarioEmpresaRepository.findOne({\r\n      where: { empleadoCentroTrabajo: { correo_1: correo } },\r\n      relations: [\r\n        'empleadoCentroTrabajo',\r\n        'empleadoCentroTrabajo.empleado',\r\n        'empleadoCentroTrabajo.centroTrabajo',\r\n        'usuarioModulos',\r\n        'usuarioModulos.rolModulo',\r\n        'usuarioModulos.rolModulo.modulo',\r\n      ],\r\n    });\r\n\r\n    if (!usuario) {\r\n      throw new NotFoundException('Usuario no encontrado');\r\n    }\r\n\r\n    return usuario;\r\n  }\r\n\r\n  async desactivarUsuario(idUsuario: number, fechaReactivacion: Date | null = null): Promise<void> {\r\n    const usuario = await this.usuarioEmpresaRepository.findOne({ where: { id_usuario_empresa: idUsuario } });\r\n\r\n    if (!usuario) {\r\n      throw new NotFoundException('Usuario no encontrado');\r\n    }\r\n\r\n    usuario.estado = 'INACTIVO';\r\n    usuario.fecha_desactivacion = new Date();\r\n    usuario.fecha_reactivacion = fechaReactivacion;\r\n\r\n    await this.usuarioEmpresaRepository.save(usuario);\r\n  }\r\n\r\n  async reactivarUsuario(idUsuario: number): Promise<void> {\r\n    const usuario = await this.usuarioEmpresaRepository.findOne({ where: { id_usuario_empresa: idUsuario } });\r\n\r\n    if (!usuario) {\r\n      throw new NotFoundException('Usuario no encontrado');\r\n    }\r\n\r\n    if (usuario.fecha_reactivacion && usuario.fecha_reactivacion > new Date()) {\r\n      throw new BadRequestException('El usuario no puede ser reactivado antes de la fecha de reactivación');\r\n    }\r\n\r\n    usuario.estado = 'ACTIVO';\r\n    usuario.fecha_desactivacion = null;\r\n    usuario.fecha_reactivacion = null;\r\n    usuario.fecha_verificacion = new Date();\r\n\r\n    await this.usuarioEmpresaRepository.save(usuario);\r\n  }\r\n\r\n  @Cron('0 0 * * *') // Se ejecuta cada día a medianoche\r\n  async reactivarUsuariosAutomaticamente() {\r\n    const usuarios = await this.usuarioEmpresaRepository.find({\r\n      where: {\r\n        estado: 'INACTIVO',\r\n        fecha_reactivacion: LessThan(new Date()),\r\n      },\r\n    });\r\n\r\n    for (const usuario of usuarios) {\r\n      usuario.estado = 'ACTIVO';\r\n      usuario.fecha_desactivacion = null;\r\n      usuario.fecha_reactivacion = null;\r\n      usuario.fecha_verificacion = new Date();\r\n      await this.usuarioEmpresaRepository.save(usuario);\r\n    }\r\n  }\r\n\r\n  async cambiarContrasena(correo: string, nuevaContrasena: string) {\r\n    const usuario = await this.usuarioEmpresaRepository.findOne({\r\n      where: { empleadoCentroTrabajo: { correo_1: correo } },\r\n    });\r\n\r\n    if (!usuario) {\r\n      throw new NotFoundException('Usuario no encontrado');\r\n    }\r\n\r\n    const salt = await bcrypt.genSalt(10);\r\n    usuario.contrasena = await bcrypt.hash(nuevaContrasena, salt);\r\n\r\n    await this.usuarioEmpresaRepository.save(usuario);\r\n\r\n    return { message: 'Contraseña cambiada con éxito' };\r\n  }\r\n\r\n  async preRegistroAdmin(createPreRegistroDto: CreatePreRegistroDto): Promise<void> {\r\n    const { nombreEmpleado, nombrePuesto, correo, numeroEmpleado, idModulo } = createPreRegistroDto;\r\n\r\n    // Verificar si el usuario ya existe\r\n    const usuarioExistente = await this.usuarioEmpresaRepository.findOne({\r\n      relations: ['empleadoCentroTrabajo'],\r\n      where: {\r\n        empleadoCentroTrabajo: {\r\n          correo_1: correo,\r\n        },\r\n      },\r\n    });\r\n\r\n    if (usuarioExistente) {\r\n      throw new BadRequestException('El correo ya está registrado');\r\n    }\r\n\r\n    // Verificar si el módulo existe y obtener el centro de trabajo\r\n    const modulo = await this.moduloRepository.findOne({\r\n      where: { id_modulo: idModulo },\r\n      relations: ['centroTrabajo'],\r\n    });\r\n\r\n    if (!modulo) {\r\n      throw new BadRequestException('El módulo especificado no existe');\r\n    }\r\n\r\n    // Asignar el rol de administrador (ID_ROLE_ADMIN)\r\n    const rolAdmin = await this.rolModuloRepository.findOne({\r\n      where: { modulo: { id_modulo: idModulo }, nombre: 'ADMINISTRADOR' },\r\n    });\r\n\r\n    if (!rolAdmin) {\r\n      throw new BadRequestException('El rol de administrador no existe para el módulo especificado');\r\n    }\r\n\r\n    // Crear un nuevo empleado\r\n    const nuevoEmpleado = this.empleadoRepository.create({\r\n      nombreEmpleado,\r\n    });\r\n\r\n    const empleado = await this.empleadoRepository.save(nuevoEmpleado);\r\n\r\n    // Crear una nueva relación de empleado con centro de trabajo\r\n    const nuevoEmpleadoCentroTrabajo = this.empleadoCentroTrabajoRepository.create({\r\n      empleado,\r\n      correo_1: correo,\r\n      numeroEmpleado,\r\n      nombrePuesto,\r\n      centroTrabajo: modulo.centroTrabajo,\r\n    });\r\n\r\n    const empleadoCentroTrabajo = await this.empleadoCentroTrabajoRepository.save(nuevoEmpleadoCentroTrabajo);\r\n\r\n    // Crear un nuevo usuario\r\n    const nuevoUsuario = this.usuarioEmpresaRepository.create({\r\n      estado: 'PENDIENTE',\r\n      contrasena: await bcrypt.hash('temporal', 10),\r\n      empleadoCentroTrabajo: empleadoCentroTrabajo,\r\n    });\r\n\r\n    const usuarioGuardado = await this.usuarioEmpresaRepository.save(nuevoUsuario);\r\n\r\n    // Crear la relación en Net_Usuario_Modulo\r\n    const usuarioModulo = this.usuarioModuloRepository.create({\r\n      usuarioEmpresa: usuarioGuardado,\r\n      rolModulo: rolAdmin,\r\n    });\r\n\r\n    await this.usuarioModuloRepository.save(usuarioModulo);\r\n\r\n    // Generar un token JWT para la verificación de correo\r\n    const token = this.jwtService.sign({ correo });\r\n\r\n    // Enviar correo electrónico de verificación\r\n    const verificationUrl = `${process.env.HOST_FRONTEND}/register?token=${token}`;\r\n    const imageUrl = \"https://inprema.gob.hn/servicios-electronicos/\"\r\n    const htmlContent = `\r\n   <div style=\"font-family: Arial, sans-serif; line-height: 1.6;\">\r\n     <h2 style=\"color: #13776B;\">¡Bienvenido a INPRENET!</h2>\r\n     <p>Hola ${nombreEmpleado},</p>\r\n     <p>Estamos encantados de tenerte con nosotros y queremos asegurarnos de que tengas la mejor experiencia posible desde el primer día.</p>\r\n     <div style=\"text-align: center;\">\r\n     <img src=\"${imageUrl}\" alt=\"Logo INPREMA\" style=\"max-width: 120px; margin-bottom: 10px;\">\r\n     <p>Para empezar, necesitamos que completes tu registro como administrador. Esto nos ayudará a personalizar tu experiencia y asegurarnos de que tienes acceso a todas las funcionalidades de nuestra aplicación.</p>\r\n     <p>Por favor, completa tu registro haciendo clic en el siguiente enlace:</p>\r\n     <div style=\"text-align: center; margin: 20px 0;\">\r\n       <a href=\"${verificationUrl}\" style=\"background-color: #13776B; color: white; padding: 10px 20px; text-decoration: none; border-radius: 4px;\">Completar Registro</a>\r\n     </div>\r\n     <p>Si tienes alguna pregunta o necesitas ayuda, no dudes en contactarnos.</p>\r\n     <p>¡Gracias por unirte a nosotros!</p>\r\n     <p>El equipo de INPRENET</p>\r\n   </div>`;\r\n    await this.mailService.sendMail(correo, 'Completa tu registro', '', htmlContent);\r\n  }\r\n\r\n  async preRegistro(createPreRegistroDto: CreatePreRegistroDto): Promise<void> {\r\n    const { nombreEmpleado, nombrePuesto, correo, numeroEmpleado, idRole, municipio, departamento } = createPreRegistroDto;\r\n\r\n    // Verificar si el usuario ya existe\r\n    const usuarioExistente = await this.usuarioEmpresaRepository.findOne({\r\n      relations: ['empleadoCentroTrabajo'],\r\n      where: {\r\n        empleadoCentroTrabajo: {\r\n          correo_1: correo,\r\n        },\r\n      },\r\n    });\r\n\r\n    if (usuarioExistente) {\r\n      throw new BadRequestException('El correo ya está registrado');\r\n    }\r\n\r\n    // Buscar el rol asociado\r\n    const rol = await this.rolModuloRepository.findOne({\r\n      where: { id_rol_modulo: idRole },\r\n      relations: ['modulo', 'modulo.centroTrabajo'],\r\n    });\r\n\r\n    if (!rol) {\r\n      throw new BadRequestException('El rol especificado no existe');\r\n    }\r\n\r\n    // Crear y guardar el nuevo empleado\r\n    const nuevoEmpleado = this.empleadoRepository.create({ nombreEmpleado });\r\n    const empleado = await this.empleadoRepository.save(nuevoEmpleado);\r\n\r\n    // Crear y guardar la relación empleado-centro de trabajo con municipio y departamento\r\n    const nuevoEmpleadoCentroTrabajo = this.empleadoCentroTrabajoRepository.create({\r\n      empleado,\r\n      correo_1: correo,\r\n      numeroEmpleado,\r\n      nombrePuesto,\r\n      centroTrabajo: rol.modulo.centroTrabajo,\r\n      municipio,   // Agregado\r\n      departamento // Agregado\r\n    });\r\n\r\n    const empleadoCentroTrabajo = await this.empleadoCentroTrabajoRepository.save(nuevoEmpleadoCentroTrabajo);\r\n\r\n    // Crear y guardar el usuario\r\n    const nuevoUsuario = this.usuarioEmpresaRepository.create({\r\n      estado: 'PENDIENTE',\r\n      contrasena: await bcrypt.hash('temporal', 10),\r\n      empleadoCentroTrabajo,\r\n    });\r\n\r\n    const usuarioGuardado = await this.usuarioEmpresaRepository.save(nuevoUsuario);\r\n\r\n    // Crear y guardar la relación usuario-módulo\r\n    const usuarioModulo = this.usuarioModuloRepository.create({\r\n      usuarioEmpresa: usuarioGuardado,\r\n      rolModulo: rol,\r\n    });\r\n\r\n    await this.usuarioModuloRepository.save(usuarioModulo);\r\n\r\n    // Generar token y enviar correo\r\n    const token = this.jwtService.sign({ correo });\r\n\r\n    const logoPath = path.join(process.cwd(), 'assets', 'images', 'LOGO-INPRENET.png');\r\n    if (!fs.existsSync(logoPath)) {\r\n      this.logger.error('El archivo LOGO-INPRENET.png no se encontró en la ruta: ' + logoPath);\r\n      throw new InternalServerErrorException('Error: El archivo LOGO-INPRENET.png no se encuentra en la ruta especificada.');\r\n    }\r\n\r\n    const verificationUrl = `${process.env.HOST_FRONTEND}/register?token=${token}`;\r\n\r\n    const htmlContent = `\r\n      <div style=\"font-family: Arial, sans-serif; line-height: 1.6;\">\r\n        <h2 style=\"color: #13776B;\">¡Bienvenido a \r\n          <span style=\"color: #14776B;\">INPRE</span><span style=\"color: #33E4DC;\">NET</span>!\r\n        </h2>\r\n        <p>Hola ${nombreEmpleado},</p>\r\n        <p>Estamos encantados de tenerte con nosotros y queremos asegurarnos de que tengas la mejor experiencia posible desde el primer día.</p>\r\n        <div style=\"text-align: center;\">\r\n          <img src=\"cid:logoInprema\" alt=\"Logo INPREMA\" style=\"width: 250px; height: auto; margin-bottom: 10px;\">\r\n          <p>Para empezar, necesitamos que completes tu registro. Esto nos ayudará a personalizar tu experiencia y asegurarnos de que tienes acceso a todas las funcionalidades de nuestra aplicación.</p>\r\n          <p>Por favor, completa tu registro haciendo clic en el siguiente enlace:</p>\r\n          <div style=\"text-align: center; margin: 20px 0;\">\r\n            <a href=\"${verificationUrl}\" style=\"background-color: #13776B; color: white; padding: 10px 20px; text-decoration: none; border-radius: 4px;\">Completar Registro</a>\r\n          </div>\r\n          <p>Si tienes alguna pregunta o necesitas ayuda, no dudes en contactarnos.</p>\r\n          <p>¡Gracias por unirte a nosotros!</p>\r\n          <p>El equipo de INPRENET</p>\r\n        </div>\r\n      </div>`;\r\n\r\n    await this.mailService.sendMail(correo, 'Completa tu registro', '', htmlContent, [\r\n      {\r\n        filename: 'LOGO-INPRENET.png',\r\n        path: logoPath,\r\n        cid: 'logoInprema'\r\n      }\r\n    ]);\r\n}\r\n\r\nasync preRegistroMasivo(createPreRegistroDtos: CreatePreRegistroDto[]): Promise<void> {\r\n  const usuariosAGuardar = [];\r\n  const usuariosModuloAGuardar = [];\r\n  const correosRegistrados: string[] = [];\r\n\r\n  for (const createPreRegistroDto of createPreRegistroDtos) {\r\n      const { nombreEmpleado, nombrePuesto, correo, numeroEmpleado, idRole, municipio, departamento } = createPreRegistroDto;\r\n\r\n      // Verificar si el usuario ya existe\r\n      const usuarioExistente = await this.usuarioEmpresaRepository.findOne({\r\n          relations: ['empleadoCentroTrabajo'],\r\n          where: {\r\n              empleadoCentroTrabajo: {\r\n                  correo_1: correo,\r\n              },\r\n          },\r\n      });\r\n\r\n      if (usuarioExistente) {\r\n          correosRegistrados.push(correo);\r\n          continue; // Saltar este registro\r\n      }\r\n\r\n      // Buscar el rol asociado\r\n      const rol = await this.rolModuloRepository.findOne({\r\n          where: { id_rol_modulo: idRole },\r\n          relations: ['modulo', 'modulo.centroTrabajo'],\r\n      });\r\n\r\n      if (!rol) {\r\n          throw new BadRequestException(`El rol especificado (${idRole}) no existe`);\r\n      }\r\n\r\n      // Crear y guardar el nuevo empleado\r\n      const nuevoEmpleado = this.empleadoRepository.create({ nombreEmpleado });\r\n      const empleado = await this.empleadoRepository.save(nuevoEmpleado);\r\n\r\n      // Crear y guardar la relación empleado-centro de trabajo con municipio y departamento\r\n      const nuevoEmpleadoCentroTrabajo = this.empleadoCentroTrabajoRepository.create({\r\n          empleado,\r\n          correo_1: correo,\r\n          numeroEmpleado,\r\n          nombrePuesto,\r\n          centroTrabajo: rol.modulo.centroTrabajo,\r\n          municipio,\r\n          departamento,\r\n      });\r\n\r\n      const empleadoCentroTrabajo = await this.empleadoCentroTrabajoRepository.save(nuevoEmpleadoCentroTrabajo);\r\n\r\n      // Crear usuario pero no guardarlo aún\r\n      const nuevoUsuario = this.usuarioEmpresaRepository.create({\r\n          estado: 'PENDIENTE',\r\n          contrasena: await bcrypt.hash('temporal', 10),\r\n          empleadoCentroTrabajo,\r\n      });\r\n\r\n      usuariosAGuardar.push(nuevoUsuario);\r\n\r\n      // Crear la relación usuario-módulo\r\n      const usuarioModulo = this.usuarioModuloRepository.create({\r\n          usuarioEmpresa: nuevoUsuario,\r\n          rolModulo: rol,\r\n      });\r\n\r\n      usuariosModuloAGuardar.push(usuarioModulo);\r\n  }\r\n\r\n  // Guardar todos los usuarios en una sola transacción para mejorar rendimiento\r\n  const usuariosGuardados = await this.usuarioEmpresaRepository.save(usuariosAGuardar);\r\n\r\n  // Asociar cada usuario guardado con su respectivo módulo\r\n  for (let i = 0; i < usuariosGuardados.length; i++) {\r\n      usuariosModuloAGuardar[i].usuarioEmpresa = usuariosGuardados[i];\r\n  }\r\n\r\n  await this.usuarioModuloRepository.save(usuariosModuloAGuardar);\r\n\r\n  // Enviar correos solo a los usuarios nuevos\r\n  for (const usuario of usuariosGuardados) {\r\n      const token = this.jwtService.sign({ correo: usuario.empleadoCentroTrabajo.correo_1 });\r\n      const verificationUrl = `${process.env.HOST_FRONTEND}/register?token=${token}`;\r\n\r\n      const htmlContent = `\r\n      <div style=\"font-family: Arial, sans-serif; line-height: 1.6;\">\r\n          <h2 style=\"color: #13776B;\">¡Bienvenido a \r\n          <span style=\"color: #14776B;\">INPRE</span><span style=\"color: #33E4DC;\">NET</span>!\r\n          </h2>\r\n          <p>Hola ${usuario.empleadoCentroTrabajo.empleado.nombreEmpleado},</p>\r\n          <p>Estamos encantados de tenerte con nosotros y queremos asegurarnos de que tengas la mejor experiencia posible desde el primer día.</p>\r\n          <div style=\"text-align: center;\">\r\n          <img src=\"cid:logoInprema\" alt=\"Logo INPREMA\" style=\"width: 250px; height: auto; margin-bottom: 10px;\">\r\n          <p>Para empezar, necesitamos que completes tu registro. Esto nos ayudará a personalizar tu experiencia y asegurarnos de que tienes acceso a todas las funcionalidades de nuestra aplicación.</p>\r\n          <p>Por favor, completa tu registro haciendo clic en el siguiente enlace:</p>\r\n          <div style=\"text-align: center; margin: 20px 0;\">\r\n              <a href=\"${verificationUrl}\" style=\"background-color: #13776B; color: white; padding: 10px 20px; text-decoration: none; border-radius: 4px;\">Completar Registro</a>\r\n          </div>\r\n          <p>Si tienes alguna pregunta o necesitas ayuda, no dudes en contactarnos.</p>\r\n          <p>¡Gracias por unirte a nosotros!</p>\r\n          <p>El equipo de INPRENET</p>\r\n          </div>\r\n      </div>`;\r\n\r\n      await this.mailService.sendMail(usuario.empleadoCentroTrabajo.correo_1, 'Completa tu registro', '', htmlContent, [\r\n          {\r\n              filename: 'LOGO-INPRENET.png',\r\n              path: path.join(process.cwd(), 'assets', 'images', 'LOGO-INPRENET.png'),\r\n              cid: 'logoInprema'\r\n          }\r\n      ]);\r\n  }\r\n\r\n  if (correosRegistrados.length > 0) {\r\n      throw new BadRequestException(`Los siguientes correos ya estaban registrados: ${correosRegistrados.join(', ')}`);\r\n  }\r\n}\r\n\r\n\r\n\r\n  async completarRegistro(\r\n    token: string,\r\n    completeRegistrationDto: CompleteRegistrationDto,\r\n    archivoIdentificacionBuffer: Buffer | null,\r\n    fotoEmpleadoBuffer: Buffer | null,\r\n  ): Promise<void> {\r\n    const {\r\n      correo,\r\n      contrasena,\r\n      telefonoEmpleado,\r\n      telefonoEmpleado2,\r\n      numero_identificacion,\r\n    } = completeRegistrationDto;\r\n  \r\n    try {\r\n      // Verificar el token ignorando su expiración\r\n      const decoded = this.jwtService.verify(token, { ignoreExpiration: true });\r\n      if (decoded.correo !== correo) {\r\n        throw new BadRequestException('El correo no coincide');\r\n      }\r\n    } catch (error) {\r\n      throw new BadRequestException('Token inválido');\r\n    }\r\n  \r\n    const usuario = await this.usuarioEmpresaRepository.findOne({\r\n      where: {\r\n        estado: 'PENDIENTE',\r\n        empleadoCentroTrabajo: {\r\n          correo_1: correo,\r\n        },\r\n      },\r\n      relations: ['empleadoCentroTrabajo', 'empleadoCentroTrabajo.empleado'],\r\n    });\r\n  \r\n    if (!usuario) {\r\n      throw new BadRequestException('Usuario no encontrado o ya registrado');\r\n    }\r\n  \r\n    usuario.contrasena = await bcrypt.hash(contrasena, 10);\r\n    usuario.estado = 'ACTIVO';\r\n    usuario.fecha_verificacion = new Date();\r\n    usuario.empleadoCentroTrabajo.empleado.telefono_1 = telefonoEmpleado;\r\n    usuario.empleadoCentroTrabajo.empleado.telefono_2 = telefonoEmpleado2;\r\n    usuario.empleadoCentroTrabajo.empleado.numero_identificacion = numero_identificacion;\r\n  \r\n    // Solo asigna los archivos si están definidos\r\n    if (archivoIdentificacionBuffer) {\r\n      usuario.empleadoCentroTrabajo.empleado.archivo_identificacion = archivoIdentificacionBuffer;\r\n    }\r\n    if (fotoEmpleadoBuffer) {\r\n      usuario.empleadoCentroTrabajo.empleado.foto_empleado = fotoEmpleadoBuffer;\r\n    }\r\n  \r\n    await this.empleadoRepository.save(usuario.empleadoCentroTrabajo.empleado);\r\n    await this.usuarioEmpresaRepository.save(usuario);\r\n  }\r\n  \r\n  \r\n  async actualizarEmpleado(\r\n    id: number,\r\n    updateEmpleadoParcialDto: any,\r\n    archivoIdentificacionBuffer: Buffer | null,\r\n    fotoEmpleadoBuffer: Buffer | null\r\n  ) {\r\n    const empleado = await this.empleadoRepository.findOne({\r\n      where: { id_empleado: id },\r\n    });\r\n\r\n    if (!empleado) {\r\n      throw new NotFoundException('Empleado no encontrado');\r\n    }\r\n    empleado.nombreEmpleado = updateEmpleadoParcialDto.nombreEmpleado || empleado.nombreEmpleado;\r\n    empleado.telefono_1 = updateEmpleadoParcialDto.telefono_1 || empleado.telefono_1;\r\n    empleado.telefono_2 = updateEmpleadoParcialDto.telefono_2 || empleado.telefono_2;\r\n    empleado.numero_identificacion = updateEmpleadoParcialDto.numero_identificacion || empleado.numero_identificacion;\r\n    if (archivoIdentificacionBuffer) {\r\n      empleado.archivo_identificacion = archivoIdentificacionBuffer;\r\n    }\r\n\r\n    if (fotoEmpleadoBuffer) {\r\n      empleado.foto_empleado = fotoEmpleadoBuffer;\r\n    }\r\n\r\n    return this.empleadoRepository.save(empleado);\r\n  }\r\n\r\n  async getRolesPorEmpresa(centroId: number) {\r\n    /* return this.rolEmpresaRepository.find({\r\n      where: {\r\n        centroTrabajo: { id_centro_trabajo: centroId },\r\n        nombre: Not('ADMINISTRADOR')\r\n      },\r\n    }); */\r\n  }\r\n\r\n  /*  async findAllRolesExceptAdmin(): Promise<Net_Rol[]> {\r\n    return this.rolRepository.createQueryBuilder('rol')\r\n      .where('rol.nombre_rol != :nombre_rol', { nombre_rol: 'ADMINISTRADOR' })\r\n      .getMany();\r\n  } */\r\n\r\n  async getUsuariosPorCentro(centroTrabajoId: number) {\r\n    /* try {\r\n      const usuarios = await this.usuarioRepository.createQueryBuilder('usuario')\r\n        .innerJoinAndSelect('usuario.empleadoCentroTrabajo', 'empleadoCentroTrabajo')\r\n        .innerJoinAndSelect('empleadoCentroTrabajo.centroTrabajo', 'centroTrabajo')\r\n        .innerJoinAndSelect('empleadoCentroTrabajo.empleado', 'empleado')\r\n        .where('centroTrabajo.id_centro_trabajo = :centroTrabajoId', { centroTrabajoId })\r\n        .getMany();\r\n\r\n      return usuarios;\r\n    } catch (error) {\r\n      this.logger.error(`Failed to get users for center with id ${centroTrabajoId}`, error.stack);\r\n      throw new Error(`Failed to get users for center with id ${centroTrabajoId}`);\r\n    } */\r\n  }\r\n\r\n  findAll(paginationDto: PaginationDto) {\r\n    /* const { limit = 10, offset = 0 } = paginationDto\r\n    return this.usuarioRepository.find({\r\n      take: limit,\r\n      skip: offset\r\n    }); */\r\n  }\r\n\r\n  findOne(id: number) {\r\n    return `This action returns a #${id} usuario`;\r\n  }\r\n\r\n  async update(updateUsuarioDto: UpdateUsuarioDto) {\r\n    /*  const { token, contrasena, nombre_puesto, telefono_empleado, numero_empleado, ...restUsuario } = updateUsuarioDto;\r\n \r\n     if (!contrasena) {\r\n       throw new BadRequestException('La contraseña es requerida');\r\n     }\r\n \r\n     let decoded;\r\n     try {\r\n       decoded = this.jwtService.verify(token);\r\n     } catch (error) {\r\n       throw new BadRequestException('Token inválido');\r\n     }\r\n \r\n     const { correo, id_usuario } = decoded;\r\n     const usuario = await this.usuarioRepository.findOne({\r\n       where: { correo, id_usuario },\r\n       relations: ['empleado']\r\n     });\r\n \r\n     if (!usuario) {\r\n       throw new NotFoundException('Usuario no encontrado');\r\n     }\r\n \r\n     usuario.contrasena = await bcrypt.hash(contrasena, 10);\r\n     Object.assign(usuario, restUsuario); // Actualiza propiedades del usuario\r\n     usuario.estado = 'ACTIVO';\r\n     usuario.fecha_verificacion = new Date();\r\n \r\n     // Actualizar datos del usuario\r\n     await this.usuarioRepository.save(usuario);\r\n \r\n     // Verificar y actualizar el empleado relacionado\r\n     if (usuario.empleado) {\r\n       usuario.empleado.nombre_puesto = nombre_puesto;\r\n       usuario.empleado.telefono_empleado = telefono_empleado;\r\n       usuario.empleado.numero_empleado = numero_empleado; \r\n       await this.empleadoRepository.save(usuario.empleado);\r\n     } else {\r\n       throw new NotFoundException('Empleado asociado no encontrado');\r\n     }\r\n \r\n     return { success: true, msg: 'Usuario y empleado actualizados correctamente' }; */\r\n  }\r\n\r\n  remove(id: number) {\r\n    return `This action removes a #${id} usuario`;\r\n  }\r\n\r\n  async obtenerUsuariosPorModuloYCentroTrabajo(modulos: string[], idCentroTrabajo: number): Promise<any[]> {\r\n    try {\r\n      const queryBuilder = this.usuarioEmpresaRepository.createQueryBuilder('usuarioEmpresa')\r\n        .leftJoinAndSelect('usuarioEmpresa.empleadoCentroTrabajo', 'empleadoCentroTrabajo')\r\n        .leftJoinAndSelect('empleadoCentroTrabajo.empleado', 'empleado')\r\n        .leftJoinAndSelect('empleadoCentroTrabajo.centroTrabajo', 'centroTrabajo')\r\n        .leftJoinAndSelect('centroTrabajo.municipio', 'municipio')\r\n        .leftJoinAndSelect('centroTrabajo.modulos', 'modulos')\r\n        .leftJoinAndSelect('modulos.roles', 'roles')\r\n        .leftJoinAndSelect('roles.modulo', 'rolesModulo')\r\n        .where('centroTrabajo.id_centro_trabajo = :idCentroTrabajo', { idCentroTrabajo })\r\n        .andWhere('modulos.nombre IN (:...modulos)', { modulos })\r\n        .select([\r\n          'usuarioEmpresa.id_usuario_empresa',\r\n          'usuarioEmpresa.estado',\r\n          'usuarioEmpresa.fecha_creacion',\r\n          'usuarioEmpresa.fecha_verificacion',\r\n          'usuarioEmpresa.fecha_modificacion',\r\n          'empleadoCentroTrabajo.id_empleado_centro_trabajo',\r\n          'empleadoCentroTrabajo.correo_1',\r\n          'empleadoCentroTrabajo.correo_2',\r\n          'empleadoCentroTrabajo.numeroEmpleado',\r\n          'empleadoCentroTrabajo.nombrePuesto',\r\n          'empleado.id_empleado',\r\n          'empleado.nombreEmpleado',\r\n          'empleado.telefono_1',\r\n          'empleado.telefono_2',\r\n          'empleado.numero_identificacion',\r\n          'empleado.archivo_identificacion',\r\n          'empleado.foto_empleado',\r\n          'centroTrabajo.id_centro_trabajo',\r\n          'centroTrabajo.nombre_centro_trabajo',\r\n          'municipio.id_municipio',\r\n          'municipio.nombre_municipio',\r\n          'modulos.id_modulo',\r\n          'modulos.nombre',\r\n          'roles.id_rol_modulo',\r\n          'roles.nombre',\r\n          'rolesModulo.id_modulo',\r\n          'rolesModulo.nombre'\r\n        ]);\r\n\r\n      const usuariosModulos = await queryBuilder.getMany();\r\n\r\n      // Convertir los blobs a base64 antes de retornar los datos\r\n      const usuariosModulosConBase64 = usuariosModulos.map(usuario => {\r\n        if (usuario.empleadoCentroTrabajo && usuario.empleadoCentroTrabajo.empleado) {\r\n          return {\r\n            ...usuario,\r\n            empleadoCentroTrabajo: {\r\n              ...usuario.empleadoCentroTrabajo,\r\n              empleado: {\r\n                ...usuario.empleadoCentroTrabajo.empleado,\r\n                archivo_identificacion: usuario.empleadoCentroTrabajo.empleado.archivo_identificacion\r\n                  ? Buffer.from(usuario.empleadoCentroTrabajo.empleado.archivo_identificacion).toString('base64')\r\n                  : null,\r\n                foto_empleado: usuario.empleadoCentroTrabajo.empleado.foto_empleado\r\n                  ? Buffer.from(usuario.empleadoCentroTrabajo.empleado.foto_empleado).toString('base64')\r\n                  : null,\r\n              },\r\n            },\r\n          };\r\n        }\r\n        return usuario;\r\n      });\r\n\r\n      return usuariosModulosConBase64;\r\n    } catch (error) {\r\n      console.error('Error al obtener usuarios por módulo y centro de trabajo:', error);\r\n      throw new Error('Error al obtener usuarios por módulo y centro de trabajo.');\r\n    }\r\n  }\r\n\r\n  async obtenerRolesPorModulo(modulo: string): Promise<net_rol_modulo[]> {\r\n    return await this.rolModuloRepository.createQueryBuilder('rol')\r\n      .innerJoinAndSelect('rol.modulo', 'modulo')\r\n      .where('modulo.nombre = :modulo', { modulo })\r\n      .getMany();\r\n  }\r\n\r\n  async obtenerModulosPorCentroTrabajo(idCentroTrabajo: number): Promise<net_modulo[]> {\r\n    return this.moduloRepository.find({\r\n      where: {\r\n        centroTrabajo: {\r\n          id_centro_trabajo: idCentroTrabajo,\r\n        },\r\n      },\r\n      relations: ['centroTrabajo'],\r\n    });\r\n  }\r\n\r\n  async crearTokenRestablecimiento(usuario: Net_Usuario_Empresa): Promise<string> {\r\n    const payload = { id: usuario.id_usuario_empresa, email: usuario.empleadoCentroTrabajo.correo_1 };\r\n    return this.jwtService.sign(payload, { expiresIn: '1h' });\r\n  }\r\n  \r\n  async buscarUsuarioPorCorreo(correo: string): Promise<Net_Usuario_Empresa | null> {\r\n    return this.usuarioEmpresaRepository.findOne({\r\n      where: { empleadoCentroTrabajo: { correo_1: correo } },\r\n      relations: ['empleadoCentroTrabajo'],\r\n    });\r\n  }\r\n\r\n  async enviarCorreoRestablecimiento(correo: string, token: string): Promise<void> {\r\n    const urlRestablecimiento = `${process.env.HOST_FRONTEND}/restablecer-contrasena/${token}`;\r\n    const asunto = 'Solicitud de restablecimiento de contraseña - INPRENET';\r\n    const htmlContent = `\r\n      <div style=\"font-family: Arial, sans-serif; line-height: 1.6; text-align: center;\">\r\n        <h2 style=\"color: #13776B;\">\r\n          Solicitud de restablecimiento de contraseña en \r\n          <span style=\"color: #14776B;\">INPRE</span><span style=\"color: #33E4DC;\">NET</span>\r\n        </h2>\r\n        <p>Hola,</p>\r\n        <p>Recientemente has solicitado restablecer tu contraseña en nuestra plataforma.</p>\r\n        <p>Para proceder con el restablecimiento, por favor haz clic en el siguiente enlace:</p>\r\n        <div style=\"text-align: center; margin: 20px 0;\">\r\n          <a href=\"${urlRestablecimiento}\" style=\"background-color: #13776B; color: white; padding: 10px 20px; text-decoration: none; border-radius: 4px;\">Restablecer contraseña</a>\r\n        </div>\r\n        <p>Este enlace es válido por un tiempo limitado. Si no solicitaste este cambio, puedes ignorar este mensaje.</p>\r\n        <p>Si tienes alguna pregunta o necesitas asistencia, no dudes en contactarnos.</p>\r\n        <p>El equipo de <strong><span style=\"color: #14776B;\">INPRE</span><span style=\"color: #33E4DC;\">NET</span></strong></p>\r\n      </div>`;\r\n    \r\n    const textoPlano = `Hola,\\n\\nHas solicitado restablecer tu contraseña en nuestra plataforma INPRENET.\\n\\nPara hacerlo, por favor, haz clic en el siguiente enlace o cópialo en tu navegador: ${urlRestablecimiento}\\n\\nSi no solicitaste este cambio, puedes ignorar este correo.\\n\\nEl equipo de INPRENET`;\r\n  \r\n    try {\r\n      await this.mailService.sendMail(correo, asunto, textoPlano, htmlContent);\r\n    } catch (error) {\r\n      console.error('Error al enviar el correo de restablecimiento:', error.message);\r\n      throw new InternalServerErrorException('No se pudo enviar el correo de restablecimiento. Por favor, inténtelo más tarde.');\r\n    }\r\n  }\r\n  \r\n  async restablecerContrasena(token: string, nuevaContrasena: string): Promise<void> {\r\n    let payload;\r\n    try {\r\n      payload = this.jwtService.verify(token);\r\n    } catch (error) {\r\n      if (error.name === 'TokenExpiredError') {\r\n        throw new BadRequestException('El enlace para restablecer la contraseña ha expirado');\r\n      }\r\n      throw new NotFoundException('Token no válido o ha expirado');\r\n    }\r\n  \r\n    const usuario = await this.usuarioEmpresaRepository.findOne({\r\n      where: { id_usuario_empresa: payload.id },\r\n    });\r\n  \r\n    if (!usuario) {\r\n      throw new NotFoundException('Usuario no encontrado');\r\n    }\r\n  \r\n    usuario.contrasena = await bcrypt.hash(nuevaContrasena, 10);\r\n  \r\n    await this.usuarioEmpresaRepository.save(usuario);\r\n  \r\n    console.info(\r\n      `Contraseña restablecida correctamente para el usuario: ${usuario.id_usuario_empresa}`,\r\n    );\r\n  }\r\n\r\n}"
        }
      }
    }
  }
}