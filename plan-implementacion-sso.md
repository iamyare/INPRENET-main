# Plan de Implementación de Single Sign-On (SSO) con Control de Sesión Única

## 1. Contexto Actual

```mermaid
graph TD
    A[Usuario] -->|Login| B[Auth Service]
    B -->|Valida Credenciales| C[Users Service]
    C -->|Genera Token| D[JWT]
    D -->|Guarda Token| E[NET_SESION Table]
    E -->|Retorna Token| A
```

### Componentes Existentes

- Tabla `NET_SESION` para gestión de sesiones
- Manejo de tokens JWT
- Control de inactividad en frontend
- Manejo básico de sesiones por dispositivo

## 2. Cambios Propuestos

### 2.1 Backend (NestJS)

#### A. Base de Datos

```sql
-- Crear tabla NET_SESION
CREATE TABLE NET_SESION (
  ID_SESION NUMBER GENERATED BY DEFAULT AS IDENTITY,
  TOKEN VARCHAR2(255) NOT NULL,
  FECHA_CREACION TIMESTAMP(6) DEFAULT CURRENT_TIMESTAMP NOT NULL,
  FECHA_EXPIRACION TIMESTAMP(6),
  ESTADO VARCHAR2(20) DEFAULT 'activa' NOT NULL,
  ID_USUARIO_PRIVADA NUMBER,
  ID_USUARIO NUMBER,
  CONSTRAINT FK_SESION_NET_SESION PRIMARY KEY (ID_SESION),
  CONSTRAINT FK_ID_USUARIO_NET_SESION FOREIGN KEY (ID_USUARIO) REFERENCES "NET_USUARIO_EMPRESA" ("ID_USUARIO_EMPRESA")
);

-- Índices para optimización
CREATE INDEX idx_net_sesion_token ON NET_SESION(TOKEN);
CREATE INDEX idx_net_sesion_usuario ON NET_SESION(ID_USUARIO, ESTADO);
```

#### B. Arquitectura de Servicios

```mermaid
graph TD
    A[Auth Controller] -->|Login Request| B[Auth Service]
    B -->|Validate| C[Users Service]
    B -->|Manage Sessions| D[Session Service]
    D -->|Store| E[(NET_SESION)]
    F[SSE Controller] -->|Emit Events| G[Connected Clients]
    H[Session Guard] -->|Validate| D
    I[Session Middleware] -->|Check Active| D
```

1. **SessionService (Nuevo)**

   ```typescript
   @Injectable()
   export class SessionService {
     async createSession(userId: number, token: string): Promise<void> {
       // Invalidar sesiones anteriores
       await this.invalidatePreviousSessions(userId)

       // Crear nueva sesión
       await this.sesionRepository.save({
         token,
         id_usuario: userId,
         fecha_expiracion: addDays(new Date(), 1),
         estado: 'activa'
       })
     }

     async invalidatePreviousSessions(userId: number): Promise<void> {
       await this.sesionRepository.update(
         { id_usuario: userId, estado: 'activa' },
         { estado: 'inactiva' }
       )
     }

     async validateSession(token: string): Promise<boolean> {
       const session = await this.sesionRepository.findOne({
         where: { token, estado: 'activa' }
       })

       if (!session) return false

       if (session.fecha_expiracion < new Date()) {
         await this.invalidateSession(session.id_sesion)
         return false
       }

       return true
     }
   }
   ```

2. **SSE Controller (Nuevo)**

   ```typescript
   @Controller('api/sse')
   export class SSEController {
     @Get('session-events')
     @Sse()
     sessionEvents(): Observable<MessageEvent> {
       return interval(1000).pipe(
         map(() => ({ data: { type: 'session-check' } }))
       )
     }
   }
   ```

3. **Middleware de Sesión Activa (Actualizar)**
   - Verificar token activo en NET_SESION
   - Actualizar fecha de expiración
   - Validar estado de la sesión

### 2.2 Frontend (Angular)

```mermaid
graph TD
    A[Auth Service] -->|Login| B[HTTP Client]
    A -->|Subscribe| C[Session Events Service]
    C -->|SSE Events| D[Session Manager]
    D -->|Handle Logout| E[Router]
    D -->|Show Alert| F[Toast Service]
```

1. **SessionEventsService (Nuevo)**

```typescript
@Injectable({
  providedIn: 'root'
})
export class SessionEventsService {
  private eventSource: EventSource

  constructor() {
    this.eventSource = new EventSource('/api/sse/session-events')
    this.eventSource.onmessage = (event) => {
      // Manejar eventos de sesión
      const data = JSON.parse(event.data)
      if (data.type === 'session-invalidated') {
        this.handleSessionInvalidation()
      }
    }
  }

  private handleSessionInvalidation() {
    // Lógica de manejo de sesión invalidada
  }
}
```

2. **AuthInterceptor (Actualizar)**

   - Adjuntar token en headers
   - Manejar errores de sesión
   - Redireccionar en caso de sesión inválida

3. **UI Components**
   - Modal de sesión terminada
   - Indicador de sesión activa

## 3. Flujos de Trabajo

### 3.1 Inicio de Sesión

```mermaid
sequenceDiagram
    participant U as Usuario
    participant F as Frontend
    participant B as Backend
    participant DB as NET_SESION
    participant SSE as SSE Events

    U->>F: Login
    F->>B: POST /auth/login
    B->>DB: Verificar credenciales
    B->>DB: Invalidar sesiones anteriores
    B->>DB: Crear nueva sesión
    B->>SSE: Emitir evento de sesión
    B->>F: Retornar nuevo token
    F->>U: Redirigir a dashboard
```

### 3.2 Validación Continua

```mermaid
sequenceDiagram
    participant F as Frontend
    participant B as Backend
    participant DB as NET_SESION
    participant SSE as SSE Events

    F->>B: Request con token
    B->>DB: Verificar sesión activa
    alt Sesión inválida
        B->>SSE: Emitir evento de invalidación
        SSE->>F: Notificar invalidación
        F->>F: Cerrar sesión local
    else Sesión válida
        B->>F: Respuesta exitosa
        F->>F: Actualizar último acceso
    end
```

## 4. Beneficios del Cambio

1. **Estructura Optimizada**

   - Modelo de datos más limpio y estandarizado
   - Mejor integración con el esquema existente
   - Índices optimizados para consultas frecuentes

2. **Mejor Control de Sesiones**

   - Estados de sesión claramente definidos
   - Manejo automático de expiración
   - Trazabilidad mejorada

3. **Seguridad Mejorada**
   - Validación robusta de sesiones
   - Control de sesiones concurrentes
   - Expiración automática

## 5. Plan de Implementación

1. **Fase 1: Base de Datos**

   - Crear tabla NET_SESION
   - Migrar datos existentes (si aplica)
   - Crear índices necesarios

2. **Fase 2: Backend**

   - Implementar SessionService
   - Actualizar UsuarioService
   - Configurar controladores SSE

3. **Fase 3: Frontend**

   - Implementar SessionEventsService
   - Actualizar AuthService
   - Crear componentes UI

4. **Fase 4: Pruebas**

   - Validar flujo de inicio de sesión
   - Probar manejo de sesiones múltiples
   - Verificar eventos SSE

5. **Fase 5: Despliegue**
   - Ejecutar scripts de base de datos
   - Desplegar cambios en backend
   - Actualizar frontend
   - Monitorear comportamiento
